/*  Iker Ruiz Arnauda 2015
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.If not, see<https://www.gnu.org/licenses/>.
*/

namespace IKMINER.Ethash
{
    public class Kernel
    {
        public static string EthereumKernel = "\r\n#define GROUP_SIZE {0}\r\n#define DAG_SIZE {1}\r\n#define LIGHT_SIZE {2}\r\n#define ACCESSES 64\r\n#define MAX_OUTPUTS {3}U\r\n#define ETHASH_DATASET_PARENTS 256\r\n#define NODE_WORDS (64/4)\r\n#define THREADS_PER_HASH (128 / 16)\r\n#define HASHES_PER_LOOP (GROUP_SIZE / THREADS_PER_HASH)\r\n\r\nstatic void keccak_f1600_round(uint2* a)\r\n{\r\n\tuint2 t[25];\r\n\tuint ux;\r\n    uint uy;\r\n\r\n    #pragma unroll 5\r\n\tfor (uint r = 0; r < 5; r++)\r\n\t\tt[r] = a[r] ^ a[r + 5] ^ a[r + 10] ^ a[r + 15] ^ a[r + 20];\r\n\t\r\n\tux = t[4].x ^ ((t[1].x << 1) | (t[1].y >> 31));\r\n\tuy = t[4].y ^ ((t[1].y << 1) | (t[1].x >> 31));\r\n    \r\n    #pragma unroll 5\r\n\tfor (uint r = 0; r < 25; r=r+5)\r\n    {\r\n\t\ta[r].x ^= ux;\r\n        a[r].y ^= uy;\r\n    }\r\n\r\n\tux = t[0].x ^ ((t[2].x << 1) | (t[2].y >> 31));\r\n\tuy = t[0].y ^ ((t[2].y << 1) | (t[2].x >> 31));\r\n\r\n    #pragma unroll 5\r\n\tfor (uint r = 1; r < 26; r=r+5)\r\n    {\r\n\t\ta[r].x ^= ux;\r\n        a[r].y ^= uy;\r\n    }\r\n\r\n\tux = t[1].x ^ ((t[3].x << 1) | (t[3].y >> 31));\r\n\tuy = t[1].y ^ ((t[3].y << 1) | (t[3].x >> 31));\r\n\t\r\n    #pragma unroll 5\r\n    for (uint r = 2; r < 27; r=r+5)\r\n    {\r\n\t\ta[r].x ^= ux;\r\n        a[r].y ^= uy;\r\n    }\r\n\r\n\tux = t[2].x ^ ((t[4].x << 1) | (t[4].y >> 31));\r\n\tuy = t[2].y ^ ((t[4].y << 1) | (t[4].x >> 31));\r\n\t\r\n    #pragma unroll 5\r\n    for (uint r = 3; r < 28; r=r+5)\r\n    {\r\n\t\ta[r].x ^= ux;\r\n        a[r].y ^= uy;\r\n    }\r\n\r\n\tux = t[3].x ^ ((t[0].x << 1) | (t[0].y >> 31));\r\n\tuy = t[3].y ^ ((t[0].y << 1) | (t[0].x >> 31));\r\n\r\n    #pragma unroll 5\r\n\tfor (uint r = 4; r < 29; r=r+5)\r\n    {\r\n\t\ta[r].x ^= ux;\r\n        a[r].y ^= uy;\r\n    }\r\n\r\n\tt[0] = a[0];\r\n\tt[1].x =  ((a[6 ].y << 12) | (a[6 ].x >> 20)); \r\n\tt[1].y =  ((a[6 ].x << 12) | (a[6 ].y >> 20));\r\n\tt[2].x =  ((a[12].y << 11) | (a[12].x >> 21)); \r\n\tt[2].y =  ((a[12].x << 11) | (a[12].y >> 21));\r\n\tt[3].x =  ((a[18].x << 21) | (a[18].y >> 11));\r\n\tt[3].y =  ((a[18].y << 21) | (a[18].x >> 11));\r\n\tt[4].x =  ((a[24].x << 14) | (a[24].y >> 18));\r\n\tt[4].y =  ((a[24].y << 14) | (a[24].x >> 18));\r\n\t\r\n    t[5].x =  ((a[ 3].x << 28) | (a[3 ].y >> 4)); \r\n\tt[5].y =  ((a[3 ].y << 28) | (a[ 3].x >> 4));\r\n\tt[6].x =  ((a[ 9].x << 20) | (a[9 ].y >> 12));\r\n\tt[6].y =  ((a[ 9].y << 20) | (a[9 ].x >> 12));\r\n\tt[7].x =  ((a[10].x << 3 ) | (a[10].y >> 29));\r\n\tt[7].y =  ((a[10].y << 3 ) | (a[10].x >> 29));  \r\n\tt[8].x =  ((a[16].y << 13) | (a[16].x >> 19));\r\n\tt[8].y =  ((a[16].x << 13) | (a[16].y >> 19));\r\n\tt[9].x =  ((a[22].y << 29) | (a[22].x >> 3));\r\n\tt[9].y =  ((a[22].x << 29) | (a[22].y >> 3));\r\n\t\r\n    t[10].x = ((a[1 ].x << 1 ) | (a[ 1].y >> 31));\r\n\tt[10].y = ((a[ 1].y << 1 ) | (a[1 ].x >> 31));\r\n\tt[11].x = ((a[7 ].x << 6 ) | (a[ 7].y >> 26));\r\n\tt[11].y = ((a[7 ].y << 6 ) | (a[7 ].x >> 26));\r\n\tt[12].x = ((a[13].x << 25) | (a[13].y >> 7));\r\n\tt[12].y = ((a[13].y << 25) | (a[13].x >> 7));\r\n\tt[13].x = ((a[19].x << 8 ) | (a[19].y >> 24));\r\n\tt[13].y = ((a[19].y << 8 ) | (a[19].x >> 24));\r\n\tt[14].x = ((a[20].x << 18) | (a[20].y >> 14));\r\n\tt[14].y = ((a[20].y << 18) | (a[20].x >> 14));\r\n\t\r\n    t[15].x = ((a[ 4].x << 27) | (a[4 ].y >> 5));\r\n\tt[15].y = ((a[4 ].y << 27) | (a[4 ].x >> 5));\r\n\tt[16].x = ((a[5 ].y << 4 ) | (a[ 5].x >> 28));\r\n\tt[16].y = ((a[5 ].x << 4 ) | (a[ 5].y >> 28));\r\n\tt[17].x = ((a[11].x << 10) | (a[11].y >> 22));\r\n\tt[17].y = ((a[11].y << 10) | (a[11].x >> 22));\r\n\tt[18].x = ((a[17].x << 15) | (a[17].y >> 17));\r\n\tt[18].y = ((a[17].y << 15) | (a[17].x >> 17));\r\n\tt[19].x = ((a[23].y << 24) | (a[23].x >> 8));\r\n\tt[19].y = ((a[23].x << 24) | (a[23].y >> 8));\r\n\t\r\n    t[20].x = ((a[2 ].y << 30) | (a[ 2].x >> 2));\r\n\tt[20].y = ((a[2 ].x << 30) | (a[2 ].y >> 2));\r\n\tt[21].x = ((a[8 ].y << 23) | (a[8 ].x >> 9));\r\n\tt[21].y = ((a[8 ].x << 23) | (a[8 ].y >> 9));\r\n\tt[22].x = ((a[14].y << 7 ) | (a[14].x >> 25));\r\n\tt[22].y = ((a[14].x << 7 ) | (a[14].y >> 25));\r\n\tt[23].x = ((a[15].y << 9 ) | (a[15].x >> 23));\r\n\tt[23].y = ((a[15].x << 9 ) | (a[15].y >> 23));\r\n\tt[24].x = ((a[21].x << 2 ) | (a[21].y >> 30));\r\n\tt[24].y = ((a[21].y << 2 ) | (a[21].x >> 30));\r\n\r\n    #pragma unroll 5\r\n\tfor (uint r = 0; r < 25; r=r+5)\r\n    {\r\n\t    a[r+0] = bitselect(t[r + 0] ^ t[r + 2], t[r + 0], t[r + 1]);\r\n\t    a[r+1] = bitselect(t[r + 1] ^ t[r + 3], t[r + 1], t[r + 2]);\r\n\t    a[r+2] = bitselect(t[r + 2] ^ t[r + 4], t[r + 2], t[r + 3]);\r\n\t    a[r+3] = bitselect(t[r + 3] ^ t[r + 0], t[r + 3], t[r + 4]);\r\n\t    a[r+4] = bitselect(t[r + 4] ^ t[r + 1], t[r + 4], t[r + 0]);\r\n    }\r\n}\r\n\r\n__constant uint2 const Keccak_f1600_RC[24] = {\r\n\t(uint2)(0x00000001, 0x00000000),\r\n\t(uint2)(0x00008082, 0x00000000),\r\n\t(uint2)(0x0000808a, 0x80000000),\r\n\t(uint2)(0x80008000, 0x80000000),\r\n\t(uint2)(0x0000808b, 0x00000000),\r\n\t(uint2)(0x80000001, 0x00000000),\r\n\t(uint2)(0x80008081, 0x80000000),\r\n\t(uint2)(0x00008009, 0x80000000),\r\n\t(uint2)(0x0000008a, 0x00000000),\r\n\t(uint2)(0x00000088, 0x00000000),\r\n\t(uint2)(0x80008009, 0x00000000),\r\n\t(uint2)(0x8000000a, 0x00000000),\r\n\t(uint2)(0x8000808b, 0x00000000),\r\n\t(uint2)(0x0000008b, 0x80000000),\r\n\t(uint2)(0x00008089, 0x80000000),\r\n\t(uint2)(0x00008003, 0x80000000),\r\n\t(uint2)(0x00008002, 0x80000000),\r\n\t(uint2)(0x00000080, 0x80000000),\r\n\t(uint2)(0x0000800a, 0x00000000),\r\n\t(uint2)(0x8000000a, 0x80000000),\r\n\t(uint2)(0x80008081, 0x80000000),\r\n\t(uint2)(0x00008080, 0x80000000),\r\n\t(uint2)(0x80000001, 0x00000000),\r\n\t(uint2)(0x80008008, 0x80000000),\r\n};\r\n\r\nstatic void keccak_f1600_no_absorb(uint2* a)\r\n{\r\n\tfor (uint r = 0; r < 24; r++)\r\n\t{\r\n\t\tkeccak_f1600_round(a);\r\n\r\n\t    a[0].x ^= Keccak_f1600_RC[r].x;\r\n        a[0].y ^= Keccak_f1600_RC[r].y;\r\n\t} \r\n}\r\n\r\n#define copy(dst, src, count) for (uint i = 0; i != count; ++i) { (dst)[i] = (src)[i]; }\r\n\r\ntypedef struct\r\n{\r\n\tulong ulongs[32 / sizeof(ulong)];\r\n} hash32_t;\r\n\r\ntypedef union {\r\n\tuint\t words[64 / sizeof(uint)];\r\n\tuint2\t uint2s[64 / sizeof(uint2)];\r\n\tuint4\t uint4s[64 / sizeof(uint4)];\r\n} hash64_t;\r\n\r\ntypedef union {\r\n\tuint\t words[200 / sizeof(uint)];\r\n\tuint2\t uint2s[200 / sizeof(uint2)];\r\n\tuint4\t uint4s[200 / sizeof(uint4)];\r\n} hash200_t;\r\n\r\ntypedef struct\r\n{\r\n\tuint4 uint4s[128 / sizeof(uint4)];\r\n} hash128_t;\r\n\r\ntypedef union {\r\n\tuint4 uint4s[4];\r\n\tulong ulongs[8];\r\n\tuint  uints[16];\r\n} compute_hash_share;\r\n\r\n#if PLATFORM != OPENCL_PLATFORM_NVIDIA // use maxrregs on nv\r\n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1)))\r\n#endif\r\n__kernel void ethash_search(\r\n\t__global volatile uint* restrict g_output,\r\n\t__constant hash32_t const* g_header,\r\n\t__global hash128_t const* g_dag,\r\n\tulong start_nonce,\r\n\tulong target,\r\n\tuint isolate)\r\n{\r\n\t__local compute_hash_share share[HASHES_PER_LOOP];\r\n\r\n\tuint const gid = get_global_id(0);\r\n\r\n\tulong state[25] = \r\n\t{\r\n\t\tg_header->ulongs[0],\r\n\t\tg_header->ulongs[1],\r\n\t\tg_header->ulongs[2],\r\n\t\tg_header->ulongs[3],\r\n\t\t(start_nonce + gid),\r\n\t\t0x0000000000000001,\r\n\t\t0, 0,\r\n\t\t0x8000000000000000,\r\n\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\r\n\t\r\n\tkeccak_f1600_no_absorb((uint2*)state);\r\n\t\r\n\tuint const thread_id = gid & 7;\r\n\tuint const hash_id = (gid % GROUP_SIZE) >> 3;\r\n\r\n\t__local uint *share0 = share[hash_id].uints;\r\n\tuint mixx;\r\n    uint mixy;\r\n    uint mixz;\r\n    uint mixw;  \r\n\r\n\tuint init0;\r\n\r\n\tfor (int i = 0; i < THREADS_PER_HASH; i++)\r\n\t{\r\n\t\t// share init with other threads\r\n\t\tif (i == thread_id)\r\n\t\t{\r\n\t\t\tfor (int a = 0; a < 8; a++)\r\n\t\t\t\tshare[hash_id].ulongs[a] = state[a];\r\n\t\t}                            \r\n\t\t\t\r\n\t\tmixx = share[hash_id].uint4s[thread_id & 3].x;\r\n        mixy = share[hash_id].uint4s[thread_id & 3].y;\r\n        mixz = share[hash_id].uint4s[thread_id & 3].z;\r\n        mixw = share[hash_id].uint4s[thread_id & 3].w;\r\n    \r\n\t\t// share init0\r\n\t\tif (thread_id == 0)\r\n            *share0 = mixx;\r\n\r\n        init0 = *share0;\r\n\r\n\t\tfor (uint a = 0; a < ACCESSES; a += 4)\r\n\t\t{\r\n            uint current_thread = ((a >> 2) & (THREADS_PER_HASH - 1));\r\n\r\n\t\t\tif (thread_id == current_thread)\r\n\t\t\t{\r\n\t\t\t\t*share0 = (init0 ^ a) * 0x01000193 ^ mixx;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\r\n            mixx =  mixx * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].x;\r\n            mixy =  mixy * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].y;\r\n            mixz =  mixz * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].z;\r\n            mixw =  mixw * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].w;\r\n\r\n\t\t\tif (thread_id == current_thread)\r\n\t\t\t{\r\n                *share0 = (init0 ^ (a + 1)) * 0x01000193 ^ mixy;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\r\n            mixx =  mixx * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].x;\r\n            mixy =  mixy * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].y;\r\n            mixz =  mixz * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].z;\r\n            mixw =  mixw * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].w;\r\n\r\n\t\t\tif (thread_id == current_thread)\r\n\t\t\t{\r\n                *share0 = (init0 ^ (a + 2)) * 0x01000193 ^ mixz;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\r\n            mixx =  mixx * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].x;\r\n            mixy =  mixy * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].y;\r\n            mixz =  mixz * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].z;\r\n            mixw =  mixw * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].w;\r\n\r\n\t\t\tif (thread_id == current_thread)\r\n\t\t\t{\r\n                *share0 = (init0 ^ (a + 3)) * 0x01000193 ^ mixw;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\r\n            mixx =  mixx * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].x;\r\n            mixy =  mixy * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].y;\r\n            mixz =  mixz * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].z;\r\n            mixw =  mixw * 0x01000193 ^ g_dag[*share0 % DAG_SIZE].uint4s[thread_id].w;\r\n\t\t}\r\n\r\n\t\tshare[hash_id].uints[thread_id] = ((mixx * 0x01000193 ^ mixy) * 0x01000193 ^ mixz) * 0x01000193 ^ mixw;\r\n\t\t\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\r\n\t\tif (i == thread_id)\r\n\t\t{\r\n\t\t\tstate[8] = share[hash_id].ulongs[0];\r\n\t\t\tstate[9] = share[hash_id].ulongs[1];\r\n\t\t\tstate[10] = share[hash_id].ulongs[2];\r\n\t\t\tstate[11] = share[hash_id].ulongs[3];\t\r\n\t\t}\r\n\t}\r\n\t\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t\r\n\tstate[12] = 0x0000000000000001;\r\n\tstate[13] = 0;\r\n\tstate[14] = 0;\r\n\tstate[15] = 0;\r\n\tstate[16] = 0x8000000000000000;\r\n\tstate[17] = 0;\r\n\tstate[18] = 0;\r\n\tstate[19] = 0;\r\n\tstate[20] = 0;\r\n\tstate[21] = 0;\r\n\tstate[22] = 0;\r\n\tstate[23] = 0;\r\n\tstate[24] = 0;\r\n\r\n\tkeccak_f1600_no_absorb((uint2*)state);\r\n\r\n\tif (as_ulong(as_uchar8(state[0]).s76543210) < target)\r\n\t{\r\n\t\tuint slot = min(MAX_OUTPUTS, atomic_inc(&g_output[0]) + 1);\r\n\t\tg_output[slot] = gid;\r\n\t}\r\n}\r\n\r\nstatic void SHA3_512(uint2* s, uint isolate)\r\n{\r\n    for (uint i = 8; i != 25; ++i)\r\n    {\r\n        s[i] = (uint2){ 0, 0 };\r\n    }\r\n    s[8].x = 0x00000001;\r\n    s[8].y = 0x80000000;\r\n    keccak_f1600_no_absorb(s);\r\n}\r\n\r\n__kernel void ethash_calculate_dag_item(uint start, __global hash64_t const* g_light, __global hash64_t * g_dag, uint isolate)\r\n{\r\n    uint const node_index = start + get_global_id(0);\r\n\r\n    if (node_index > DAG_SIZE * 2)\r\n        return;\r\n\r\n    hash200_t dag_node;\r\n\r\n    copy(dag_node.uint4s, g_light[node_index % LIGHT_SIZE].uint4s, 4);\r\n    dag_node.words[0] ^= node_index;\r\n\r\n    SHA3_512(dag_node.uint2s, isolate);\r\n\r\n    for (uint i = 0; i != ETHASH_DATASET_PARENTS; ++i)\r\n    {\r\n        uint parent_index = ((node_index ^ i) * 0x01000193 ^ dag_node.words[i % NODE_WORDS]) % LIGHT_SIZE;\r\n\r\n        for (uint w = 0; w != 4; ++w)\r\n        {\r\n            dag_node.uint4s[w] = dag_node.uint4s[w] * 0x01000193 ^  g_light[parent_index].uint4s[w];\r\n        }\r\n    }\r\n    SHA3_512(dag_node.uint2s, isolate);\r\n\r\n    copy(g_dag[node_index].uint4s, dag_node.uint4s, 4);\r\n}\r\n\r\n// f\r\n";

        public static void SetEthereumKernelParameters(uint workgroupSize, ulong dagSize128, ulong lightSize64, int maxSearchResults)
        {
            Kernel.EthereumKernel = Kernel.EthereumKernel.Replace("{0}", workgroupSize.ToString());
            Kernel.EthereumKernel = Kernel.EthereumKernel.Replace("{1}", dagSize128.ToString());
            Kernel.EthereumKernel = Kernel.EthereumKernel.Replace("{2}", lightSize64.ToString());
            Kernel.EthereumKernel = Kernel.EthereumKernel.Replace("{3}", maxSearchResults.ToString());
        }
    }
}
